# -*- mode:org; fill-column:79; -*-

#+TITLE:Common Lisp
#+SUBTITLE:A Gentle Introduction to Symbolic Computation
#+AUTHOR:David S. Touretzky, Carnegie Mellon University
#+DATE:1990

#+TEXINFO:@insertcopying

* Preface
  :PROPERTIES:
  :UNNUMBERED:
  :END:

  This book is about learning to program in Lisp.  Lisp is an
  excellent language for beginners.  It is increasingly the language
  of choice in introductory programming courses due to its friendly,
  interactive environment, rich data structures, and powerful software
  tools that even a novice can master in short order.

  The author had three types of readers in mind:

  - Students taking their first programming course--- ::

       The student could be from any discipline, from computer science
       to the humanities. For you, let me stress the word /gentle/ in
       the title. I assume no prior mathematical background beyond
       arithmetic. Even if you don’t like math, you may find you enjoy
       computer programming. I’ve avoided technical jargon, and there
       are lots of examples. Also you will find plenty of exercises
       interspersed with the text, and the answers to all of them are
       included in Appendix C.

  - Psychologists, linguists, computer scientists--- ::

       (and other persons interested in Artificial Intelligence.)  As
       you begin your inquiry into AI, you will see that almost all
       research in this field is carried out in Lisp. Most Lisp texts
       are written exclusively for computer science majors, but I have
       gone to great effort to make /this/ book accessible to
       everyone. It can be your doorway to the technical literature of
       AI, as well as a quick introduction to its central tool.

  - Computer hobbyists--- ::

       Prior to about 1984, the Lisps available on personal computers
       weren’t very good due to the small memories of the early
       machines. Today’s personal computers often come with several
       megabytes of RAM and a hard disk as standard equipment. They
       run full implementations of the Common Lisp standard, and
       provide the same high-quality tools as the Lisps in university
       and industrial research labs. The ``Lisp Toolkit'' sections of
       this book will introduce you to the advanced features of the
       Common Lisp programming environment that have made the language
       such a productive tool for rapid prototyping and AI
       programming.


  This current volume of the ``gentle introduction'' uses Common Lisp
  throughout. Lisp has been changing continuously since its invention
  30 years ago. In the past, not only were the Lisp dialects on
  different machines incompatible, but programs written in one dialect
  would often no longer run in that same dialect a few years later,
  because the language had evolved out from under them. Rapid,
  unconstrained evolution was beneficial in the early days, but demand
  for a standard eventually grew, so Common Lisp was created. At
  present, Common Lisp is the /de facto/ standard supported by all
  major computer manufacturers. It is currently undergoing refinement
  into an official standard. But Lisp will continue to evolve
  nonetheless, and the standard will be updated periodically to
  reflect new contributions people have made to the language. Perhaps
  one of those contributors will be you.

* Note to Instructors
  :PROPERTIES:
  :UNNUMBERED:
  :END:

  #+CINDEX:instruction, effective
  #+CINDEX:variables
  #+CINDEX:scope
  #+CINDEX:assignment
  #+CINDEX:teaching tools
  #+CINDEX:tools, teaching
  Much has been learned in the last few years about how to teach Lisp
  effectively to beginners: where they stumble and what we can do
  about it. In addition, the switch to Common Lisp has necessitated
  changes in the way certain topics are taught, especially variables,
  scoping, and assignment. This version of the ‘‘gentle introduction’’
  has been completely revised for Common Lisp, and includes several
  new teaching tools that I believe you will find invaluable in the
  classroom. Let me share with you some of the thinking behind this
  book’s novel approach to Lisp.

** Graphical Notation

   {{{heading(Summary of `Box-and-Arrow' Notation)}}}

   - graphical box-and-arrow notation
   - primitive functions
   - function composition
   - computation
   - fundamental data structures
     - numbers
     - symbols
     - lists
   - programs and data visually distinct
   - lack of explicit variables
   - EVAL notation
     - quoting
     - named variables


   {{{heading(`Box-and-Arrow' Notation)}}}

    #+CINDEX:box-and-arrow notation
    #+CINDEX:notation, box-and-arrow
    #+CINDEX:functions, primitive
    #+CINDEX:primitive functions
    #+CINDEX:function composition
    #+CINDEX:composition, function
    The first two chapters use a graphical *box-and-arrow notation*
    for describing
    - /primitive functions/ and
    - /function composition/.


    #+CINDEX:computation
    #+CINDEX:data structures, fundamental
    #+CINDEX:numbers, data structure
    #+CINDEX:symbols, data structure
    #+CINDEX:lists, data structure
    {{{noindent}}}This notation allows students to get comfortable
    with the basic idea of /computation/ and the three /fundamental
    data structures/—
    - numbers,
    - symbols, and
    - lists


    {{{noindent}}}before grappling with side issues such as
    - the syntax of a function call or
    - when to use quotes.


    #+CINDEX:data, as programs
    #+CINDEX:programs as data
    Although sophisticated Lispers profit from the realization that
    *programs are data*, to the beginner this is a major source of
    confusion.

    #+CINDEX:box-and_arrow notation, advantages
    The /box-and-arrow notation/ makes *programs* and *data* visually
    distinct, and thereby eliminates most syntax errors.

    Another advantage of this notation is its /lack of explicit
    variables/; the inputs to a function are simply arrows that enter
    the function definition from outside.  Since there is no computer
    implementation of function box notation, the first two chapters
    are designed to be covered rapidly using just pencil and
    paper.

    This also shelters the student temporarily from another source of
    frustration—--learning the mechanics of using an actual machine,
    editing expressions, and coping with the debugger.

*** Experienced Learners

    Readers who are familiar with other programming languages can flip
    through Chapter 1 in a minute or so, read the summary at the end,
    and then skim Chapter 2 to pick up the basic list manipulation
    primitives.

*** EVAL Notation

    #+CINDEX:@samp{EVAL} notation
    #+CINDEX:notation, @samp{EVAL}
    #+CINDEX:quoting
    #+CINDEX:named variables
    In Chapter 3 the student is introduced to standard EVAL notation;
    the concepts of quoting and named variables follow fairly
    naturally.  Now he or she is ready to discard paper and pencil for a
    real computer (and is probably eager to do so), whereas at the
    start of the course this might have been viewed with trepidation.

** Other Features

   #+CINDEX:features of book, unique
   #+CINDEX:evaltrace notation
   #+CINDEX:Lisp Toolkit
   #+CINDEX:data structures, graphical representation of
   #+CINDEX:function objects
   #+CINDEX:symbols, internal structure of
   Three other unique features of the book first appear in Chapter 3:
   - evaltrace notation,
   - Lisp Toolkit sections, and
   - a comprehensive graphical representation for Lisp data
     structures, including function objects and the internal structure
     of symbols.

*** Evaltrace Notation

    #+CINDEX:evaltrace notation
    #+CINDEX:evaluation of expressions
    #+CINDEX:functions, applied to arguments
    #+CINDEX:variables, created and bound
    *Evaltrace notation* shows step-by-step
    - how Lisp expressions are evaluated,
    - how functions are applied to arguments, and
    - how variables are created and bound.


    #+CINDEX:@code{EVAL}
    #+CINDEX:@code{APPLY}
    #+CINDEX:variable scoping
    #+CINDEX:scoping of variables
    #+CINDEX:lexical contours, nesting of
    - The different roles of EVAL and APPLY,
    - the scoping of variables, and
    - the nesting of lexical contours


    #+CINDEX:process of evaluation
    #+CINDEX:evaluation process, graphically notated
    {{{noindent}can all be explained graphically using this notation.
    It makes the /process of evaluation/ transparent to the student by
    describing it in a visual language which he or she can remember
    and use.

*** Lisp Toolkit

    #+CINDEX:List Toolkit
    #+CINDEX:tools, Lisp Toolkit
    #+CINDEX:programming aid
    #+CINDEX:@code{DESCRIBE}
    #+CINDEX:@code{INSPECT}
    #+CINDEX:@code{TRACE}
    #+CINDEX:@code{STEP}
    #+CINDEX:debugger
    The Lisp Toolkit sections introduce the various *programming aids*
    that Common Lisp provides, such as:
    - ~DESCRIBE~,
    - ~INSPECT~,
    - ~TRACE~,
    - ~STEP~,
    - and the debugger.


    #+CINDEX:tools, unique to book
    There are also two tools unique to this book; their source code
    appears in Appendices A and B, and is available on diskette from
    the publisher.

**** SDRAW

     #+CINDEX:@code{SDRAW}
     #+CINDEX: @code{cons} cells
     #+CINDEX:read-eval-draw loop
     #+CINDEX:@code{CONS}
     #+CINDEX:@code{LIST}
     #+CINDEX:@code{APPEND}
     The first tool, SDRAW, draws ~cons~ cell diagrams. It is part of
     a read-eval-draw loop that has proven invaluable for teaching
     beginners to reason about cons cell structures, particularly the
     differences among ~CONS~, ~LIST~, and ~APPEND~.

**** DTRACE

     #+CINDEX:@code{DTRACE}
     #+CINDEX:@code{TRACE}
     #+CINDEX:tracing package
     #+CINDEX:package, tracing
     The second tool, DTRACE, is a tracing package that generates more
     detailed output than most implementations of TRACE, and is
     therefore more useful for teaching beginners.

*** Graphical Representation of Lisp Data Structures

    #+CINDEX:data structures, graphical representation of
    #+CINDEX:symbols, internal structure of
    #+CINDEX:symbol name, function, value, plist, package cells
    #+CINDEX:plist, symbol
    #+CINDEX:package cells, symbol
    Finally, the *graphical representation of Lisp data
    structures*---particularly the internal structure of symbols with
    their:
    - name,
    - function,
    - value,
    - plist, and
    - package cells


    #+CINDEX:interpreters, true nature of
    #+CINDEX:distinctions between symbols, functions, variables, print names
    {{{noindent}}}helps students understand the true nature of Lisp
    interpreters and highlights the distinctions between
    - symbols,
    - functions,
    - variables, and
    - print names.

** Organization of Later Chapters

   #+CINDEX:side-effect free, programming style
   The book promotes a clean, side-effect-free style of programming
   for the first eight chapters.

   #+CINDEX:chapter 7
   - Chapter 7 ::

                  #+CINDEX:applicative operators
                  #+CINDEX:operators, applicative
                  #+CINDEX:lexical closures
                  #+CINDEX:closures, lexical
      /Applicative operators/ are introduced, where the student also
                  learns about /lexical closures/.

                  #+CINDEX:chapter 8
   - Chapter 8 ::

                  #+CINDEX:dragon stories
                  #+CINDEX:recursion templates
                  #+CINDEX:recursive functions
                  #+CINDEX:recursive style
      the dragon stories that were a popular feature of the previous
                  version have been retained, but they are now backed
                  up with a new device---/recursion templates/---that
                  helps beginners analyze /recursive functions/ to
                  extract the essence of the recursive style. Since
                  some instructors prefer to teach recursion before
                  applicatives, these two chapters have been written
                  so that they may be covered in either order.

                  #+CINDEX:chapter 9
                  #+CINDEX:i/o
                  #+CINDEX:input output
   - Chapter 9 :: input/output

                  #+CINDEX:chapter 10
   - Chapter 10 ::

                   #+CINDEX:assignment
                   #+CINDEX:variables, ordinary, generalized
                   #+CINDEX:destructive sequence operations
                   #+CINDEX:sequence operations, destructive
                   provides a unified picture of assignment that
                   includes ordinary variables, generalized variables,
                   and destructive sequence operations.

                   #+CINDEX:chapter 11
   - Chapter 11 ::

                   #+CINDEX:iteration
                   #+CINDEX:@code{DO}, @code{DO*}
                   #+CINDEX:iterative expressions
                   #+CINDEX:expressions, iterative
                   covers iteration, and shows how ~DO~ and ~DO*~ can
                   be used to construct substantial /iterative
                   expressions/ with no explicit assignments.

                   #+CINDEX:chapter 12
   - Chapter 12 ::

                   #+CINDEX:structures
                   introduces /structures/.

                   #+CINDEX:chapter 13
   - Chapter 13 ::

                   #+CINDEX:arrays
                   #+CINDEX:hash tables
                   #+CINDEX:property lists
                   covers arrays, hash tables, and property lists.

                   #+CINDEX:chapter 14
   - Chapter 14 ::

                   #+CINDEX:macros
                   #+CINDEX:compilation
                   #+CINDEX:scoping, lexical and dynamic, difference between
                   #+CINDEX:evaltrace diagrams
                   #+CINDEX:macros, semantics
                   #+CINDEX:special variables, semantics
                   #+CINDEX:variables, special, semantics
                   #+CINDEX:semantics, macros and special variables, difference between
                   is devoted to /macros/ and /compilation/.  It also
                   explains the difference between /lexical/ and /dynamic
                   scoping/.  Evaltrace diagrams clarify the /semantics
                   of macros and special variables/.

** Emphasis on Simplicity

   #+CINDEX:simplicity
   Because Common Lisp is such a complex language, there are a few
   places where I have chosen to simplify things to better meet the
   needs of beginners.

   For example:

     #+CINDEX:@code{1+}, @code{1-} functions
   - the ~1+~ and ~1-~ functions are banished from this book because
     their names are very confusing.
     #+CINDEX:predicates, use of
     #+CINDEX:@code{EQUAL}
     #+CINDEX:@code{EQ}
     #+CINDEX:@code{EQL}
     #+CINDEX:@code{EQUALP}
     #+CINDEX:@code{=}
   - The book relies almost exclusively on ~EQUAL~ because this is the
     most useful equality predicate.
     - ~EQ~, ~EQL~, ~EQUALP~, and ~=~ are mentioned in advanced topics
       sections, but not used very much.
     #+CINDEX:@code{PUSHNEW}
   - In a few places I have chosen to write a function slightly less
     concisely rather than introduce one of the more obscure
     primitives like ~PUSHNEW~.
     #+CINDEX:advanced features
     #+CINDEX:features, advanced
     #+CINDEX:multiple values
     #+CINDEX:values, multiple
     #+CINDEX:package system
   - And I make no attempt to cover the most advanced features, such
     as
     - multiple values or
     - the package system.


*** Why Not Teach Scheme?

    #+CINDEX:Scheme
    Some people prefer to teach Scheme in introductory courses because
    it is so much smaller than Common Lisp. But one can easily teach
    the subset of Common Lisp that is equivalent to Scheme, so
    language size isn’t really an issue for beginners.

    #+CINDEX:application programming style
    #+CINDEX:programming style, applicative
    #+CINDEX:style, applicative programming
    #+CINDEX:lexical closures
    #+CINDEX:closures, lexical
    A more compelling argument is that there is a certain style of
    applicative programming, making heavy use of lexical closures,
    that can be expressed more elegantly in Scheme syntax.

    #+CINDEX: Common Lisp, superior to Scheme, areas of
    But there are also areas where Common Lisp is superior to Scheme,
    such as
      #+CINDEX:macros, user-defined
      #+CINDEX:sequence datatype
      #+CINDEX:datatype, sequence
      #+CINDEX:unification of lists and vectors, sequence datatype
      #+CINDEX:keyword arguments
    - its support for user-defined macros,
    - its elegant unification of lists and vectors into a sequence datatype, and
    - its use of keyword arguments to greatly extend the utility of
      the sequence functions.


    #+CINDEX:Lisp, industrial strength language
    The combination of tremendous power, extensive manufacturer
    support, and a built-in object-oriented programming facility make
    Common Lisp the only ``industrial strength'' Lisp.  Although this
    book does emphasize a side-effect-free, applicative approach to
    programming with which Scheme afficionados will feel quite at
    home, it does so in purely Common Lisp style.

** Two Recommended Resources

   #+CINDEX:advanced topics
   #+CINDEX:enrichment material
   This book has been carefully designed to meet the needs of
   beginning programmers and non-computer science students, but the
   optional advanced topics sections at the end of each chapter
   provide enough enrichment material to hold the interest of junior
   and senior computer science majors.

   #+CINDEX:undergraduates, advanced
   #+CINDEX:advanced undergraduates
   #+CINDEX:Steele, Guy L. Jr.
   #+CINDEX:@cite{Common Lisp: The Language}
   For advanced undergraduates,
   - Guy L. Steele Jr.’s @@texinfo:@cite{@@Common Lisp: The
     Language@@texinfo:}@@ (published by Digital Press) would be a
     useful companion to the introduction provided here.


   #+CINDEX:beginner programmers, reference for
   #+CINDEX:Franz
   #+CINDEX:@cite{Common Lisp: The Reference}
   For beginners,
   - @@texinfo:@cite{@@Common Lisp: The Reference@@texinfo:}@@, by
     Franz, Inc. (published by Addison-Wesley) is a more suitable
     reference work.

* Functions and Data

** Introduction

   #+CINDEX:functions
   #+CINDEX:data
   #+CINDEX:built-in functions
   #+CINDEX:functions, built-in
   #+CINDEX:function, arithmetic
   #+CINDEX:arithmetic functions
   #+CINDEX:predicate function
   #+CINDEX:function, predicate
   - overview of the notions of function and data; i.e.
   - examples of several built-in Lisp functions
   - arithmetic functions,
   - an introduction to symbols, one of the key datatypes of Lisp, and
   - predicates, which answer yes-or-no questions

     #+CINDEX:result
     If you’re new to programming, this chapter is designed specifically for
     you.  We’ll start by explaining what *functions* and *data* are.  The term
     {{{dfn(data)}}} means /information/, such as numbers, words, or lists of
     things.  You can think of a {{{dfn(function)}}} as a /box through which
     data flows/.  The function operates on the data in some way, and the
     *result* is what flows out.

     #+CINDEX:function, techniques for creating new
     #+CINDEX:computer programming
     After covering some of the built-in functions provided by Lisp, we will
     learn how to put existing functions together to make new ones---the
     essence of computer programming.  Several useful techniques for creating
     new functions will then be presented.

** Functions on Numbers

   #+CINDEX:functions, arithmetic
   #+CINDEX:addition, subtraction
   #+CINDEX:multiplication, division
   #+CINDEX:@code{+}
   #+CINDEX:call, function
   #+CINDEX:invoke, function
   #+CINDEX:return, function call, invocation
   Probably the most familiar functions are the simple arithmetic functions of
   addition, subtraction, multiplication, and division.

   The name of the function is {{{code(+)}}}.

   From the programmer’s point of view: We *called* (or *invoked*) the function
   {{{code(+)}}} on the inputs 2 and 3, and the function (returned* 5.

   Here is a table of Lisp functions that do useful things with numbers:

   #+NAME:tab:math-functions
   #+CAPTION:Lisp Functions that do useful things with numbers
   |----------+--------------------------------------------|
   | Function | Description                                |
   |----------+--------------------------------------------|
   | ~+~      | Adds two numbers                           |
   | ~-~      | Subtracts the second number from the first |
   | ~*~      | Multiplies two numbers                     |
   | ~/~      | Divides the first number by the second     |
   | ~ABS~    | Absolute value of a number                 |
   | ~SQRT~   | Square root of a number                    |
   |----------+--------------------------------------------|

** Three Kinds of Numbers

   - integers
   - floating points
   - ratios

   #+CINDEX:numbers
   #+CINDEX:integers
   #+CINDEX:whole numbers
   In this book we will work mostly with *integers*, which are whole numbers.
   Common Lisp provides many other kinds of numbers.  One kind you should know
   about is *floating point* numbers.  A {{{dfn(floating point)}}} number is
   always written with a decimal point; for example, the number five would be
   written ~5.0~. The ~SQRT~ function generally returns a floating point number
   as its result, even when its input is an integer.

   #+CINDEX:ratios
   #+CINDEX:simplify ratios
   *Ratios* are yet another kind of number.  In Common Lisp we can also write
   ~one-half~ as the ratio ~1/2~.  Common Lisp automatically simplifies ratios
   to use the smallest possible denominator; for example, the ratios ~4/6~,
   ~6/9~, and ~10/15~ would all be simplified to ~2/3~.

   When we call an arithmetic function with integer inputs, Common Lisp will
   usually produce an integer or ratio result.  If we use a mixture of integers
   and floating point numbers, the result will be a floating point number:

   #+TEXINFO:@noindent@code{(/ 3 6)} @result{} @code{1/2}@*
   #+TEXINFO:@code{(/ 3 6.0)} @result{} @code{0.5}

** Order of Inputs is Important

   #+CINDEX:inputs, order
   The order in which inputs are supplied to a function is important. For
   example, dividing 8 by 2 is not the same as dividing 2 by 8.  When we divide
   8 by 2 we get 4.  When we divide 2 by 8 we get the ratio 1/4.

   Ratios need not always be less than 1.  For example:
   #+TEXINFO:@code{(/ 10 8)} @result{} @code{5/4}

** Symbols

   #+CINDEX:symbols
   #+CINDEX:data, symbol
   *Symbols* are another type of data in Lisp.  Symbols are typically named
   after English words (such as =TUESDAY=), or phrases (e.g.,
   =BUFFALO-BREATH=), or common abbreviations (like ~SQRT~ for ‘‘square
   root.’’).  Symbol names may contain practically any combination of letters
   and numbers, plus some special characters such as hyphens.  Symbols may
   include digits in their names, as in =R2D2=, but this does not make them
   numbers.  It is important that you be able to tell the difference between
   numbers---especially integers---and symbols. These definitions should help:

   #+CINDEX:integer, definition
   #+CINDEX:symbol, definition
   - integer :: A sequence of digits =0= through =9=, optionally preceded by a
                plus or minus sign.
   - symbol :: Any sequence of letters, digits, and permissible special
               characters that is not a number.


   So =FOUR= is a symbol, ~4~ is an integer, ~+4~ is an integer, but =+= is a
   symbol.  And =7-11= is also a symbol.

** The Special Symbols =T= and =NIL=

   #+CINDEX:@code{T}
   #+CINDEX:@code{NIL}
   #+CINDEX:Truth, @code{T}
   #+CINDEX:Falsity, @code{NIL}
   Two Lisp symbols have special meanings attached to them. They are:

   - =T= :: Truth, ``yes''
   - =NIL= :: Falsity, emptiness, ``no''


   #+CINDEX:predicates, definition
   Certain Lisp functions answer questions with =T= or =NIL=.  Such yes-or-no
   functions are called *predicates*.

** Some Simple Predicates

   #+CINDEX:predicate function
   #+CINDEX:question-answer function, predicate
   #+CINDEX:@code{T}
   #+CINDEX:@code{NIL}
   A {{{dfn(predicate)}}} is a question-answering function.  Predicates output
   the symbol =T= when they mean yes and the symbol =NIL= when they mean
   no.

   #+CINDEX:@code{NUMBERP}, predicate function
   The first predicate we will study is the one that tests whether its input is
   a number or not.  It is called ~NUMBERP~ (pronounced ``number-pee,'' as in
   ``number predicate''), and it looks like this:

   #+TEXINFO:@noindent@code{(NUMBERP 2)} @result{} T@*
   #+TEXINFO:@code{(NUMBERP DOG)} @result{} NIL

   #+CINDEX:@code{SYMBOLP}
   Similarly, the ~SYMBOLP~ predicate tests whether its input is a
   symbol.  ~SYMBOLP~ returns =T= when given an input that is a symbol; it returns
   =NIL= for inputs that are not symbols.

   #+TEXINFO:@noindent@code{(SYMBOLP CAT)} @result{} T@*
   #+TEXINFO:@code{(SYMBOLP 42)} @result{} NIL

   #+CINDEX:@code{ZEROP}
   #+CINDEX:@code{EVENP}
   #+CINDEX:@code{ODDP}
   The ~ZEROP~, ~EVENP~, and ~ODDP~ predicates work only on numbers.  ~ZEROP~
   returns =T= if its input is zero.  ~ODDP~ returns =T= if its input is odd;
   otherwise it returns =NIL=.  ~EVENP~ does the reverse.

   #+CINDEX:predicate, naming convention
   By now you’ve caught on to the convention of tacking a ``P'' onto a function
   name to show that it is a predicate.  Not all Lisp predicates obey this
   rule, but most do.

   #+CINDEX:@code{<}
   #+CINDEX:@code{>}
   Here are two more predicates: ~<~ returns =T= if its first input is less
   than its second, while ~>~ returns =T= if its first input is greater than
   its second.  (They are also our first exceptions to the convention that
   predicate names end with a ``P.'')

** The Equal Predicate

   #+CINDEX:@code{EQUAL}
   #+CINDEX:@code{EQ}
   #+CINDEX:@code{EQL}
   #+CINDEX:@code{EQUALP}
   ~EQUAL~ is a predicate for comparing two things to see if they are the same.
   ~EQUAL~ returns =T= if its two inputs are equal; otherwise it returns =NIL=.
   Common Lisp also includes predicates named ~EQ~, ~EQL~, and ~EQUALP~ whose
   behavior is slightly different than ~EQUAL~; the differences will not concern
   us here.  For beginners, ~EQUAL~ is the right one to use.

** Putting Functions Together

   #+CINDEX:primitive functions
   #+CINDEX:functions, primitive
   #+CINDEX:built-in functions
   #+CINDEX:functionsm, new
   #+CINDEX:new functions
   So far we’ve covered about a dozen of the many functions built into Common
   Lisp.  These built-in functions are called *primitive functions*, or
   *primitives*.  We make new functions by putting primitives together in
   various ways.

*** Defining ~ADD1~

    #+CINDEX:@code{ADD1}
    #+CINDEX:@code{+}
    Let’s define a function that adds one to its input.[fn:add1] We already
    have a primitive function for addition: The ~+~ function will add any two
    numbers it is given as input. Our ~ADD1~ function will take a single number
    as input, and add one to it.  Now that we’ve defined ~ADD1~ we can use it to
    add 1 to any number we like.

    #+TEXINFO:@noindent@code{(ADD1 5)} @result{} 6

*** Defining ~ADD2~

    #+CINDEX:@code{ADD2}
    Now suppose we want a function that adds 2 to its input.  We could define
    ~ADD2~ the same way we defined ~ADD1~.  But in Lisp there is always more
    than one way to solve a problem; sometimes it is interesting to look at
    alternative solutions. For example, we could build ~ADD2~ out of two ~ADD1~
    boxes.

    Once we’ve defined ~ADD2~, we are free to use it to add 2 to any number.
    Looking at the ~ADD2~ box from the outside, we have no way of knowing which
    solution was chosen.

    #+TEXINFO:@noindent@code{(ADD2 5)} @result{} 7

    #+CINDEX:primitive function
    But if we look inside the ~ADD2~ box we can see exactly what’s going on.
    The number 5 flows into the first ~ADD1~ box, which produces 6 as its
    result.  The 6 then flows into the second ~ADD1~ box, and its result is 7.
    If we want to peer deeper still, we could see the ~+~ box inside each
    ~ADD1~ box.  This is as deep as we can go.  We can’t look inside the ~+~
    boxes because ~+~ is a primitive function.

*** Defining ~TWOP~

    #+CINDEX:predicates, defining our own
    We can use our new knowledge to make our own predicates too, since
    predicates are just a special type of function.  Predicates are functions
    that return a result of =T= or =NIL=.  The ~TWOP~ predicate defined below
    returns =T= if its input is equal to 2.

    #+TEXINFO:@noindent@code{(TWOP 2)} @result{} T
    #+TEXINFO:@code{(TWOP 3)} @result{} NIL

*** Defining ONEMOREP

    #+CINDEX:@code{ONEMOREP} predicate
    Let’s try defining a function of two inputs.  Here is the ~ONEMOREP~
    predicate, which tests whether its first input is exactly one greater than
    its second input.

    Do you see how ~ONEMOREP~ works?  If the first input is one greater than
    the second input, adding 1 to the second input should make the two equal.
    In this case, the ~EQUAL~ predicate will return =T=.  On the other hand, if
    the first input to ~ONEMOREP~ isn’t one greater than the second input, the
    inputs to ~EQUAL~ won’t be equal, so it will return =NIL=.

    In your mind (or out loud if you prefer), trace the flow of data through
    ~ONEMOREP~ for the preceding example.  You should say something like this:

    #+BEGIN_quote
    The first input is a 7.  The second input, a 6, enters ~ADD1~, which
    outputs a 7.  The two 7’s enter the ~EQUAL~ function, and since they are
    equal, it outputs a =T=.  =T= is the result of ~ONEMOREP~.
    #+END_quote

** The ~NOT~ Predicate

   #+CINDEX:@code{NOT}
   ~NOT~ is the ``opposite'' predicate: It turns 'yes' into 'no', and 'no' into
   'yes'.  In Lisp terminology, given an input of =T=, ~NOT~ returns =NIL=.
   Given an input of =NIL=, ~NOT~ returns =T=.  The neat thing about ~NOT~ is
   that it can be attached to any other predicate to derive its opposite; for
   example, we can make a ``not equal'' predicate from ~NOT~ and ~EQUAL~, or a
   ``nonzero'' predicate from ~NOT~ and ~ZEROP~.  We’ll see how this is done in
   the next section.

   #+CINDEX:Lisp @samp{no}
   By convention, NIL is the only way to say ``no'' in Lisp.  Everything else
   is treated as ``yes''.  So ~NOT~ returns =NIL= for every input except =NIL=.
   This is not just an arbitrary convention.  It turns out to be extremely
   useful to treat =NIL= as the only ``false'' object.  You’ll see why in later
   chapters.

** Negating a Predicate

   #+CINDEX:@code{NOT-EQUAL}
   Suppose we want to make a predicate that tests whether two things are not
   equal---the opposite of the ~EQUAL~ predicate.  We can build it by starting
   with ~EQUAL~ and running its output through ~NOT~ to get the opposite
   result.  Because of the ~NOT~ function, whenever ~EQUAL~ would say =T=,
   ~NOT-EQUAL~ will say =NIL=, and whenever ~EQUAL~ would say =NIL=,
   ~NOT-EQUAL~ will say =T=.

** Number of Inputs to a Function

   Some functions require a fixed number of inputs, such as ~ODDP~, which
   accepts exactly one input, and ~EQUAL~, which takes exactly two. But many
   functions accept a variable number of inputs.  For example, the arithmetic
   functions ~+~, ~-~, ~*~, and ~/~ will accept any number of inputs.

   To multiply three numbers, the ~*~ function multiplies the first two, then
   multiplies the result by the third.  When ~-~ or ~/~ is given more than two
   inputs, the result is the first input diminished (or divided, respectively)
   by the remaining inputs.

   The ~-~ and ~/~ functions behave differently when given only one
   input.  What ~-~ does is negate its input, in other words, it changes the sign
   from positive to negative or vice versa by subtracting it from zero.  When
   the ~/~ function is given a single input, it divides one by that input, which
   gives the reciprocal.

   The two-input case is clearly the defining case for the basic arithmetic
   functions.  While they can accept more or fewer than two inputs, they convert
   those cases to instances of the two-input case.

** Errors

   Even though our system of functions is a very simple one, we can already
   make several types of errors in it. One error is to give a function the
   wrong type of data.  For example, the ~+~ function can add only numbers; it
   cannot add symbols.  Another error is to give a function too few or too many
   inputs.  Finally, an error may occur because a function cannot do what is
   requested of it.  This is what happens when we try to divide a number by
   zero.

** Summary

   In this chapter we covered two types of data: numbers and symbols. We also
   learned several built-in functions that operate on them.

   Predicates are a special class of functions that use =T= and =NIL= to answer
   questions about their inputs.  The symbol =NIL= means `false', and the
   symbol =T= means `true'.  Actually, anything other than =NIL= is treated as
   `true' in Lisp.

   A function must have a definition before we can use it.  We can make new
   functions by putting old ones together in various ways.  A particularly
   useful combination, used quite often in programming, is to feed the output
   of a predicate through the ~NOT~ function to derive its opposite, as the
   ~NOT-EQUAL~ predicate was derived from ~EQUAL~.

* Lists

** LISTS ARE THE MOST VERSATILE DATA TYPE

#+CINDEX:List Processor
``Lisp'' is an acronym for ``List Processor.''  Lists remain its central data
type.  Lists are important because they can be made to represent practically
anything: sets, tables, and graphs, and even English sentences.  Functions can
also be represented as lists.

** WHAT DO LISTS LOOK LIKE?

Every list has two forms:

#+CINDEX:printed representation, list
#+CINDEX:element of a list
- *a printed representation*; the printed representation is most convenient for
  people to use, because it’s compact and easy to type on a computer keyboard.
  We will use a /graphical notation/ when we want to refer to lists in their
  internal form.  In its printed form, a list is a bunch of items enclosed in
  parentheses. These items are called the {{{dfn(elements)}}} of the list.

  #+CINDEX:internal representation, list
  #+CINDEX:cons cell
  #+CINDEX:pointer
  #+CINDEX:NIL
- *an internal one*; the internal representation is the way the list actually
  exists in the computer’s memory.  Inside the computer’s memory, lists are
  organized as chains of {{{dfn(cons cells)}}}, which we’ll draw as boxes. The
  cons cells are linked together by {{{dfn(pointers)}}}, which we’ll draw as
  arrows.  Each cons cell has two pointers. One of them always points to an
  element of the list, such as RED, while the other points to the next cons
  cell in the chain.  The cons cell chain ends in NIL. This is a convention in
  Lisp. It may be violated in some circumstances, but most of the time lists
  will end in NIL.

  What each cons cell actually is, internally, is a small piece of memory,
  split in two, big enough to hold two addresses (pointers) to other places in
  memory where the actual data (like RED, or NIL, or another cons cell) is
  stored. On most computers pointers are four bytes long, so each cons cells is
  eight bytes.

** LISTS OF ONE ELEMENT

#+CINDEX:symbol, not a list of one
A symbol and a list of one element are not the same.

Consider the list (AARDVARK); it is represented by a cons cell.  One of the
cons cell’s pointers points to the symbol AARDVARK; the other points to NIL.
So you see that the list (AARDVARK) and the symbol AARDVARK are different
objects.  The former is a cons cell that points to the latter.

** NESTED LISTS

#+CINDEX:nested list
#+CINDEX:flat list
A list may contain other lists as elements.

- ((BLUE SKY) (GREEN GRASS) (BROWN EARTH))
- This is a list of /three lists/, not a list of six symbols.
- Lists that contain other lists are called {{{dfn(nested lists)}}}.  Lists
  that are not nested are called {{{dfn(flat lists)}}}.  A flat list has only a
  top-level cons cell chain.
- In parenthesis notation, a nested list has one or more sets of parentheses
  nested within the outermost pair.
- In cons cell notation, a nested list has at least one level of cons cells
  below the top-level chain.


Lists aren’t always uniform in shape.  Here’s a nested list whose elements are
a list, a symbol, and a list:

- ((BRAIN SURGEONS) NEVER (SAY OOPS))


Anything we write in parenthesis notation will have an equivalent description
inside the computer as a cons cell structure---if the parentheses balance
properly.

** LENGTH OF LISTS

#+CINDEX:length of list
The length of a list is the number of elements it has.  But what about lists of
lists? When a list is written in parenthesis notation, its elements are the
things that appear inside only one level of parentheses.

#+CINDEX:LENGTH, primitive function
The primitive function LENGTH computes the length of a list. It is an error to
give LENGTH a symbol or number as input.

** NIL---THE EMPTY LIST

#+CINDEX:empty list
A list of zero elements is called an {{{dfn(empty list)}}}. It has no cons
cells. It is written as an empty pair of parentheses:

=()=

#+CINDEX:NIL
Inside the computer the empty list is represented by the symbol NIL.

Thus ~(A NIL B)~ can also be written ~(A () B)~.

The length of the empty list is zero. Even though NIL is a symbol, it is still
a valid input to LENGTH because NIL is also a list. NIL is the only thing that
is both a symbol and a list.

** EQUALITY OF LISTS

#+CINDEX:EQUAL
Two lists are considered EQUAL if their corresponding elements are EQUAL.  If
two lists have different numbers of elements, they are never EQUAL.

** FIRST SECOND THIRD AND REST

#+CINDEX:FIRST
#+CINDEX:SECOND
#+CINDEX:THIRD
Lisp provides primitive functions for extracting elements from a list. The
functions FIRST, SECOND, and THIRD return the first, second, and third element
of their input, respectively.  It is an error to give these functions inputs
that are not lists.

#+CINDEX:REST
The REST function is the complement of FIRST: It returns a list containing
everything but the first element.

** FUNCTIONS OPERATE ON POINTERS

#+CINDEX:pointers
When we say that an object such as a list or symbol is an input to a function,
we are speaking informally. Inside the computer, everything is done with
pointers, so the real input to the function isn’t the object itself, but a
pointer to the object. Likewise, the result returned by a function is really a
pointer.


Suppose (THE BIG BOPPER) is supplied as input to REST. What REST actually
receives is a pointer to the first cons cell.  Computer scientists would say
that the pointer lives ``in a register'' or ``on the stack,'' but these details
need not concern us.

The result returned by REST is a pointer to the second cons cell, which is the
first cell of the list (BIG BOPPER).  Where did this pointer come from? What
REST did was extract the pointer from the right half of the first cons cell,
and return that pointer as its result. So the result of REST is a pointer into
the same cons cell chain as the input to REST.  No new cons cells were created
by REST when it returned (BIG BOPPER); all it did was extract and return a
pointer.

** CAR AND CDR

#+CINDEX:CAR
#+CINDEX:address portion of register
#+CINDEX:Contents of Address portion
#+CINDEX:CDR
#+CINDEX:decrement portion of Register
#+CINDEX:Contents of Decrement portion of Register
#+CINDEX:IBM 704
By now you know that each half of a cons cell points to something. The two
halves have obscure names. The left half is called the CAR, and the right half
is called the CDR (pronounced ``cou-der,'' rhymes with ``good-er''). These
names are relics from the early days of computing, when Lisp first ran on a
machine called the IBM 704. The 704 was so primitive it didn’t even have
transistors---it used vacuum tubes. Each of its ``registers'' was divided into
several components, two of which were the address portion and the decrement
portion.  Back then, the name CAR stood for Contents of Address portion of
Register, and CDR stood for Contents of Decrement portion of Register.  Even
though these terms don’t apply to modern computer hardware, Common Lisp still
uses the acronyms CAR and CDR when referring to cons cells, partly for
historical reasons, and partly because these names can be composed to form
longer names such as CADR and CDDAR, as you will see shortly.

#+CINDEX:CAR function
#+CINDEX:CDR function
Besides naming the two halves of a cons cell, CAR and CDR are also the names of
built-in Lisp functions that return whatever pointer is in the CAR or CDR half
of the cell, respectively.  Consider again the list (THE BIG BOPPER). When this
list is used as input to a function such as CAR, what the function actually
receives is not the list itself, but rather a pointer to the first cons cell.
CAR follows this pointer to get to the actual cons cell and extracts the
pointer sitting in the CAR half. So CAR returns as its result a pointer to the
symbol THE.  What does CDR return when given the same list as input?

CDR follows the pointer to get to the cons cell, and extracts the pointer
sitting in the CDR half, which it returns. So the result of CDR is a pointer to
the list (BIG BOPPER).

#+CINDEX:FIRST is CAR
#+CINDEX:REST is CDR
From this example you can see that CAR is the same as FIRST, and CDR is the
same as REST.  Lisp programmers usually prefer to express it the other way
around: FIRST returns the CAR of a list, and REST returns the CDR.

*** The CDR of a Single-Element List

#+CINDEX:list of length one
#+CINDEX:list of zero length, NIL
#+CINDEX:NIL, list of zero length
Since a list of length one is represented inside the computer as a single cons
cell, the CDR of a list of length one is the list of length zero, NIL.

The list ((PHONE HOME)) has only one element.  Since the CAR and CDR functions
extract their respective pointers from the first cons cell of a list, the CAR
of ((PHONE HOME)) is (PHONE HOME), and the CDR is NIL.

*** Combinations of CAR and CDR

Consider the list (FEE FIE FOE FUM), the first element of which is FEE. The
second element of this list is the FIRST of the REST, or, in our new
terminology, the CAR of the CDR.

#+CINDEX:CADR function
If you read the names of these function boxes from left to right, you’ll read
``CDR'' and then ``CAR.'' But since the input to the CAR function is the output
of the CDR function, we say in English that we are computing ``the CAR of the
CDR'' of the list, not the other way around. In Lisp, the CADR function is an
abbreviation for ``the CAR of the CDR.'' CADR is pronounced ``kae-der.''

#+CINDEX:CDAR function
What would happen if we switched the A and the D? The CDAR (``cou-dar'')
function takes the CDR of the CAR of a list. The CAR of (FEE FIE FOE FUM) is
FEE; if we try to take the CDR of that we get an error message. Obviously, CDAR
doesn’t work on lists of symbols. It works perfectly well on lists of lists,
though.

#+CINDEX:CADDR function
The CADDR (``ka-dih-der'') function returns the THIRD element of a list. (If
you’re having trouble with these strange names, see the pronunciation guide on
page 48.) Once again, the name indicates how the function works: It takes the
CAR of the CDR of the CDR of the list.

#+CINDEX:CADDR
To really understand how CADDR works, you have to read the As and Ds from right
to left. Starting with the list (FEE FIE FOE FUM), first take the CDR, yielding
(FIE FOE FUM). Then take the CDR of that, which gives (FOE FUM). Finally take
the CAR, which produces FOE.

Here’s another way to look at CADDR. Start with the CDDR (``cou-dih-der'')
function, which takes the CDR of the CDR, or the REST of the REST. The CDDR of
(FEE FIE FOE FUM) is (FOE FUM), and the CAR of that is FOE. The CAR of the CDDR
is the CADDR!

#+CINDEX:CAADDR
#+CINDEX:FIRST through TENTH
#+CINDEX:TENTH, from FIRST
Common Lisp provides built-in definitions for all combinations of CAR and CDR
up to and including four As and Ds in the function name. So CAADDR is built in,
but not CAADDAR. Common Lisp also provides built-in definitions for FIRST
through TENTH.

*** CAR and CDR of Nested Lists

#+CINDEX:CAAR function
CAR and CDR can be used to take apart nested lists just as easily as flat ones.
Let’s see how we can get at the various components of the nested list ((BLUE
CUBE) (RED PYRAMID)).  The CAR of this list is (BLUE CUBE). To get to BLUE, we
must take the CAR of the CAR. The CAAR function, pronounced ``ka-ar.''

#+CINDEX:CADAR function
What about getting to the symbol CUBE? Put your finger on the first cons cell
of the list. Following the CAR pointer from the first cell takes us to the list
(BLUE CUBE). Following the CDR pointer from that cell takes us to the list
(CUBE), and following the CAR pointer from there takes us to the symbol
CUBE. So CUBE is the CAR of the CDR of the CAR of the list, or, in short, the
CADAR (``ka-dar'').

Here’s another way to think about it. The first element of the nested list is
(BLUE CUBE), so CUBE is the SECOND of the FIRST of the list. This is the CADR
of the CAR, which is precisely the CADAR.

#+CINDEX:CAADR function
Now let’s try to get to the symbol RED. RED is the FIRST of the SECOND of the
list. You know by now that this is the CAR of the CADR. Putting the two names
together yields CAADR, which is pronounced ``ka-ae-der.''

Let’s build a table of the steps to follow to get to PYRAMID:

| STEP    | RESULT                      |
|---------+-----------------------------|
| /start/ | ((BLUE CUBE) (RED PYRAMID)) |
| C...DR  | ((RED PYRAMID))             |
| C..ADR  | (RED PYRAMID)               |
| C.DADR  | (PYRAMID)                   |
| CADADR  | PYRAMID                     |
|---------+-----------------------------|

#+NAME:tbl:car-cdr-pro-guide
#+CAPTION:CAR/CDR Pronunciation Guide
| FUNCTION | PRONUNCIATION     | ALTERNATE NAME |
|----------+-------------------+----------------|
| CAR      | /kar/             | FIRST          |
| CDR      | /cou-der/         | REST           |
| CAAR     | /ka-ar/           |                |
| CADR     | /kae-der/         | SECOND         |
| CDAR     | /cou-dar/         |                |
| CDDR     | /cou-dih-der/     |                |
| CAAAR    | /ka-a-ar/         |                |
| CAADR    | /ka-ae-der/       |                |
| CADAR    | /ka-dar/          |                |
| CADDR    | /ka-dih-der/      | THIRD          |
| CDAAR    | /cou-da-ar/       |                |
| CDADR    | /cou-dae-der/     |                |
| CDDAR    | /cou-dih-dar/     |                |
| CDDDR    | /cou-did-dih-der/ |                |
| CADDDR   | /ka-dih-dih-der/  | FOURTH         |
|----------+-------------------+----------------|

*** CAR and CDR of NIL

#+CINDEX:NIL, CAR and CDR
Here is another interesting fact about NIL: The CAR and CDR of NIL are defined
to be NIL.  In some earlier Lisp dialects it was actually an error to try to
take the CAR or CDR of NIL. But experience shows that defining the CAR and CDR
of NIL to be NIL has useful consequences in certain programming situations.

** CONS

#+CINDEX:CONS function
#+CINDEX:cons cells, from CONS
The CONS function creates cons cells.  It takes two inputs and returns a
pointer to a new cons cell whose CAR points to the first input and whose CDR
points to the second. The term ``CONS'' is short for CONStruct.

If we try to explain CONS using parenthesis notation, we might say that CONS
adds an element to the front of a list.

To really understand what CONS does, it is better to think about it using cons
cell notation. CONS is a very simple function: It doesn’t know anything about
the ``front of a list.'' (Remember, inside the computer there are no
parentheses.) All CONS does is create one new cons cell. But if the second
input to CONS is a cons cell chain of length ~n~, the new cell will form the
head of a cons cell chain of length ~n+1~.  So even though CONS just returns a
pointer to the cell it created, in effect it returns a cons cell chain one
longer than its second input.

*** CONS and the Empty List

#+CINDEX:Empty list, NIL
#+CINDEX:NIL, empty list
#+CINDEX:CONS NIL
Since NIL is the empty list, if we use CONS to add something onto NIL we get a
list of one element.

You should be able to confirm this result by looking at the cons cell notation
for the list (FROB). The CAR of (FROB) is the symbol FROB and the CDR of (FROB)
is NIL, so CONS must have built the list from the inputs FROB and NIL.

In printed notation, consing something onto NIL is equivalent to throwing an
extra pair of parentheses around it.
- CONS(SOMETHING NIL) @@texinfo:@result{}@@ (SOMETHING)

*** Building Nested Lists With CONS

#+CINDEX:nested lists, built with CONS function
Any time the first input to CONS is a nonempty list, the result will be a
nested list, that is, a list with more than one level of cons cells.

*** CONS Can Build Lists From Scratch

#+CINDEX:lists from scratch, using CONS function
Suppose we wish to construct the list (FOO BAR BAZ) from scratch. We could
start by adding the symbol BAZ onto the empty list. This gives us the list
(BAZ).  Then we can add BAR onto that.  Finally we add the FOO.  We have
cascaded three CONSs together to build the list (FOO BAR BAZ) from scratch.

** SYMMETRY OF CONS AND CAR/CDR

#+CINDEX:symmetry, CONS and CAR/CDR
There is an interesting symmetry between CONS and CAR/CDR. Given some list x,
if we know the CAR of x and the CDR of x we can CONS them together to figure
out what x is. For example, if the CAR of x is the symbol A and the CDR of x is
the list (E I O U), we know that x must be the list (A E I O U).

The symmetry between CONS and CAR/CDR can be expressed formally as:
: x = CONS of (CAR of x) and (CDR of x)

However, this relationship only holds for nonempty lists.

** LIST

#+CINDEX:LIST function
Creating a list from a bunch of elements is such a common operation that Lisp
has a built-in function to do just that. The LIST function takes any number of
inputs and makes a list of them. That is, it makes a new cons cell chain,
ending in NIL, with as many cells as there are inputs.  The LIST function, on
the other hand, makes an entirely new cons cell chain.  In parenthesis
notation, it appears to throw a pair of parentheses around its inputs, however
many there are. The result of LIST always has one more level of
parenthesization than any input had.

LIST actually works by building a new chain of cons cells. The CAR halves of
the cells point to the inputs LIST received. The result of LIST is a pointer to
the first cell in the chain.

Let’s look again at the difference between CONS and LIST. CONS makes a single
cons cell. LIST makes a new cons cell chain list out of however many inputs it
receives.  Another way to understand LIST is to think of it as expanding into a
cascade of CONS boxes.

** REPLACING THE FIRST ELEMENT OF A LIST

Suppose we want to replace the first element of a list with the symbol
WHAT. The REST function can be used to obtain the sublist beyond the first
element; then we can use CONS to add the symbol WHAT to the front of that
sublist.

** LIST PREDICATES

#+CINDEX:predicates, list
#+CINDEX:list predicates
#+CINDEX:LISTP predicate
The LISTP predicate returns T if its input is a list. LISTP returns NIL for
non-lists.

#+CINDEX:CONSP predicate
The CONSP predicate returns T if its input is a cons cell. CONSP is almost the
same as LISTP; the difference is in their treatment of NIL. NIL is a list, but
it is not a cons cell.

#+CINDEX:ATOM predicate
The ATOM predicate returns T if its input is anything other than a cons
cell. ATOM and CONSP are opposites; when one returns T, the other always
returns NIL.

#+CINDEX:atom
The word ``atom'' comes from the Greek /atomos/, meaning indivisible. Numbers
and symbols are atomic because they cannot be taken apart. Nonempty lists
aren’t atomic: FIRST and REST take them apart.

#+CINDEX:NULL predicate
The NULL predicate returns T if its input is NIL. Its behavior is the same as
the NOT predicate. By convention, Lisp programmers reserve NOT for logical
operations: changing /true/ to /false/ and /false/ to /true/. They use NULL
when they want to test whether a list is empty.

** SUMMARY

This chapter introduced the most versatile data type in Lisp: lists.

- Lists have both a printed and an internal representation.

- They may contain numbers, symbols, or other lists as elements.

- We can take lists apart using CAR and CDR (``first'' and ``rest'') and put
  them together with CONS or LIST.

- The LENGTH function counts the number of elements in a list, which is the
  same as its number of top-level cons cells.


The important points about CAR and CDR are:

- CAR and CDR accept only lists as input.

- FIRST and REST are the same as CAR and CDR.

- SECOND and THIRD are the same as CADR and CADDR.

- Common Lisp provides built-in C...R functions for all combinations of CAR and
  CDR up to and including four As and Ds.


The symbol NIL has several interesting properties:

- NIL is a symbol. It is the only way to say ‘‘no’’ or ‘‘false’’ in Lisp.

- NIL is a list. It is the empty list; its LENGTH is zero.

- NIL is the only Lisp object that is both a symbol and a list.

- NIL marks the end of a cons cell chain. When lists are printed in parenthesis
  notation, the NILs at the end of chains are omitted by convention.

- NIL and () are interchangeable notations for the same object.

- The CAR and CDR of NIL are defined to be NIL.

** FUNCTIONS COVERED IN THIS CHAPTER

List functions:

- FIRST
- SECOND
- THIRD
- FOURTH
- REST
- CAR
- CDR
- CONS
- LIST
- LENGTH


Compositions of CAR and CDR: CADR, CADDR, and so on.

Predicates:

- LISTP
- CONSP
- ATOM
- NULL

* EVAL Notation

** INTRODUCTION TO EVAL NOTATION

#+CINDEX:EVAL notation
#+CINDEX:notation, EVAL
Before progressing further in our study of Lisp, we must switch to a more
flexible notation, called EVAL notation.  Instead of using boxes to represent
functions, we will use lists.

#+CINDEX:EVAL notation, advantages
EVAL notation has several advantages:

- Programming concepts that are too sophisticated to express in box notation
  can be expressed in EVAL notation.
- EVAL notation is easy to type on a computer keyboard; box notation is not.
  #+CINDEX:functions as lists
- From a mathematical standpoint, representing functions as ordinary lists is
  an elegant thing to do, because then we can use exactly the same notation for
  functions as for data.
  #+CINDEX:functions are data
- In Lisp, functions are data, and EVAL notation allows us to write functions
  that accept other functions as inputs.[fn:1]
- When you have mastered EVAL notation, you will know most of what you need to
  begin conversing in Lisp with a computer.

** THE EVAL FUNCTION

#+CINDEX:EVAL function
#+CINDEX:evaluate Lisp expressions
#+CINDEX:expression, function followed by inputs
The EVAL function is the heart of Lisp.  EVAL’s job is to evaluate Lisp
*expressions* to compute their result.  Most expressions consist of a function
followed by a set of inputs.

#+BEGIN_cartouche
If we give EVAL the expression ~(+ 2 3)~, for example, it will invoke the
built-in function ~+~ on the inputs 2 and 3, and ~+~ will return 5.  We
therefore say the expression ~(+ 2 3)~ *evaluates* to 5.
#+END_cartouche

: (+ 2 3) --> [ EVAL ] ==> 5

#+CINDEX:arrow
From now on, instead of drawing an EVAL box we’ll just use an arrow. The
preceding example will be written like this:

#+TEXINFO: @code{(+ 2 3)} @result{} 5

#+CINDEX:arrow, two-headed
When we want to be slightly more verbose, we’ll use a two-headed arrow:

#+BEGIN_EXAMPLE
|--> (+ 2 3)
|
|--> 5
#+END_EXAMPLE

#+CINDEX:arrow, three-headed
And when we want to show as much detail as possible, we will use a three-
headed arrow, like this:

#+BEGIN_EXAMPLE
|--> (+ 2 3)
|
||==> Enter + with inputs 2 and 3
||
||==> Result of + is 5
#+END_EXAMPLE

#+CINDEX:expressions, EVAL notation
Here are some more examples of expressions in EVAL notation:

#+BEGIN_EXPORT texinfo
@example
(+ 1 6) @result{} 7
(oddp (+ 1 6)) @result{} t
(* 3 (+ 1 6)) @result{} 21
(/ (* 2 11) (+ 1 6)) @result{} 22/7
@end example
#+END_EXPORT

** EVAL NOTATION CAN DO ANYTHING BOX NOTATION CAN DO

It should be obvious that any expression we write in box notation can also be
written in EVAL notation.

** EVALUATION RULES DEFINE THE BEHAVIOR OF EVAL

#+CINDEX:evaluation rules
#+CINDEX:rules, evaluation
EVAL works by following a set of evaluation rules.

- One rule is that numbers and certain other objects are ``self-evaluating,''
  meaning they evaluate to themselves.  The special symbols ~T~ and ~NIL~ also
  evaluate to themselves.

  #+BEGIN_EXPORT texinfo
  @example
  23 @result{} 23
  t @result{} t
  nil @result{} nil
  @end example
  #+END_EXPORT

#+CINDEX:evaluation rule for numbers, t, nil
#+BEGIN_cartouche
 {{{noindent}}} *Evaluation Rule for Numbers, T, and NIL:* /Numbers, and the
 symbols T and NIL, evaluate to themselves./
#+END_cartouche

#+CINDEX:evaluate lists
- There is also a rule for evaluating lists.

  The first element of a list specifies a function to call; the remaining
  elements are the unevaluated *arguments* to the function. These arguments
  must be evaluated, in left to right order, to determine the inputs to the
  function.

#+CINDEX:evaluation rule for lists
#+BEGIN_cartouche
{{{noindent}}} *Evaluation Rule for Lists:* /The first element of the list
specifies a function to be called. The remaining elements specify arguments to/
/the function.  The function is called on the evaluated arguments./
#+END_cartouche

#+CINDEX:evaltrace diagram
The following diagram, called an {{{dfn(evaltrace diagram)}}}, shows how the
evaluation of ~(ODDP (+ 1 6))~ takes place.  Notice that evaluation proceeds
from the inner nested expression, ~(+ 1 6)~, to the outer expression,
ODDP. This inner-to-outer quality is reflected in the shape of the evaltrace
diagram.

** DEFINING FUNCTIONS IN EVAL NOTATION

#+CINDEX:define functions in EVAL notation
#+CINDEX:EVAL notation, define functions
In EVAL notation we use lists to define functions, and we refer to the
function’s arguments by giving them names.

The AVERAGE function is defined in EVAL notation this way:

#+BEGIN_EXAMPLE
(defun average (x y)
  (/ (+ x y) 2.0))
#+END_EXAMPLE

#+CINDEX:macro function
#+CINDEX:defun macro function
DEFUN is a special kind of function, called a {{{dfn(macro function)}}}, that
does not evaluate its arguments.  Therefore they do not have to be quoted.

DEFUN[fn:2] is used to define other functions.

- The first input to DEFUN is the name of the function being defined.
  #+CINDEX:argument list to defun
  #+CINDEX:defun argument list
- The second input is the {{{dfn(argument list)}}}: It specifies the names the
  function will use to refer to its arguments.
  #+CINDEX:body of defun
  #+CINDEX:defun body
- The remaining inputs to DEFUN define the {{{dfn(body)}}} of the function:
  what goes on ``inside the box.''


#+CINDEX:call a function
Once you’ve typed the function definition for AVERAGE into the computer, you
can call AVERAGE using EVAL notation.  When you type ~(AVERAGE 6 8)~, for
example, AVERAGE uses 6 as the value for X and 8 as the value for Y. The
result, naturally, is 7.0.

Here is another example of function definition with DEFUN:

: (defun square (n) (* n n))

The function’s name is SQUARE.  Its argument list is ~(N)~, meaning it accepts
one argument which it refers to as ~N~.  The body of the function is the
expression ~(* N N)~.  The right way to read this definition aloud (or in your
head) is: ``DEFUN SQUARE of N, times N N.''

#+CINDEX:argument to function, symbol
Almost any symbol except T or NIL can serve as the name of an argument. X, Y,
and N are commonly used, but BOZO or ARTICHOKE would also work. Functions are
more readable when their argument names mean something. A function that
computed the total cost of a merchandise order might name its arguments
QUANTITY, PRICE, and HANDLING-CHARGE.

#+BEGIN_EXAMPLE
(defun total-cost (quantity price handling-charge)
    (+ (* quantity price) handling-charge))
#+END_EXAMPLE

** VARIABLES

#+CINDEX:variable, definition
A {{{dfn(variable)}}} is /a place where data is stored./

Let’s consider the AVERAGE function again. When we call AVERAGE, Lisp creates
two new variables to hold the inputs so that the expression in the body can
refer to them by name. The names of the variables are X and Y.

#+CINDEX:variables, symbols
#+CINDEX:symbols, variables
It is important to distinguish here between variables and symbols. Variables
are not symbols; *variables are named by symbols*. Functions are also named by
symbols.

#+CINDEX:variable value
The value of a variable is the data it holds.

When we evaluate ~(AVERAGE 3 7)~, Lisp creates variables named X and Y and
assigns them the values 3 and 7, respectively. In the body of AVERAGE, the
symbol X refers to the first variable and the symbol Y refers to the
second.

These variables can only be referenced inside the body; outside of AVERAGE they
are inaccessible.  Of course the symbols X and Y still exist outside of
AVERAGE, but they don’t have the same meanings outside as they have inside.Of
course the symbols X and Y still exist outside of AVERAGE, but they don’t have
the same meanings outside as they have inside.

** EVALUATING SYMBOLS

The names a function uses for its arguments are independent of the names any
other function uses. Two functions such as HALF and SQUARE might both call
their argument N, but when N appears in HALF it can only refer to the input of
HALF; it has no relation to the use of N in SQUARE.

{{{heading(Evaluation Rule for Sumbols)}}}

The rule EVAL uses for evaluating symbols is simple:

#+BEGIN_cartouche
*Evaluation Rule for Symbols:* /A symbol evaluates to the value of the variable
 it refers to./
#+END_cartouche

{{{heading(Global and Local Variables)}}}

#+CINDEX:global variable
Outside the bodies of HALF and SQUARE, the symbol N refers to the global
variable named N. A {{{dfn(global variable)}}} is one that is not associated
with any function. PI is an example of a global variable that is built in to
Common Lisp.

#+BEGIN_EXPORT texinfo
@example
PI @result{} 3.14159
@end example
#+END_EXPORT

{{{heading(Evaluating Variables and Symbols)}}}

#+CINDEX:evaluating variables
#+CINDEX:evaluating symbols
Informally, Lisp programmers sometimes talk of evaluating variables. They might
say ``variables evaluate to their values.''  What they really mean is that /a
symbol evaluates to the value of the variable it refers to./

Since there can be many variables named N, which one you get depends on where
the symbol N appears. If it appears inside the body of SQUARE, you get the
variable that holds the input to SQUARE. If it appears outside of any function,
you get the *global variable* named N.

{{{heading(Unassigned Variable)}}}

#+CINDEX:unassigned variable error
#+CINDEX:error, unassigned variable
Lisp will complain if you ask it for the value of a variable that has not been
assigned a value. We refer to this as an ``unassigned variable error.''

** USING SYMBOLS AND LISTS AS DATA

#+CINDEX:symbols as data
Suppose we want to call EQUAL on the symbols KIRK and SPOCK.

In EVAL notation symbols are used to name variables, so if we write:
: (equal kirk spock)
Lisp will think we are trying to compare the value of the global variable named
KIRK with the value of the global variable named SPOCK. Since we haven’t given
any values to these variables, this will cause an error:
: (equal kirk spock) ⇒ Error! KIRK unassigned variable.

What we really want to do is compare the symbols themselves. We can tell Lisp
to *treat KIRK and SPOCK as data rather than as variable references* by putting
a quote before each one.
: (equal ’kirk ’spock) ⇒ nil

Because the symbols T and NIL evaluate to themselves, they don’t need to be
quoted to use them as data. Most other symbols do, though.

#+CINDEX:prevent evaluation, quoting
Whether symbols are used as data in a function definition, or are passed as
inputs when the function is called, *they must be quoted to prevent
evaluation.*

#+BEGIN_EXAMPLE
(defun riddle (x y)
    (list 'why 'is 'a x 'like 'a y))

(riddle 'raven 'writing-desk) ⇒
    (why is a raven like a writing-desk)
#+END_EXAMPLE

#+CINDEX:lists as data
Lists also need to be quoted to use them as data; otherwise Lisp will try to
evaluate them, which typically results in an ``undefined function'' error.

#+BEGIN_EXAMPLE
(first (we hold these truths))
    ⇒ Error! WE undefined function.

(first ’(we hold these truths)) ⇒ we
#+END_EXAMPLE

{{{heading(Evaluation Rule for Quoted Objects)}}}

#+BEGIN_cartouche
*Evaluation Rule for Quoted Objects:* /A quoted object evaluates to the object
itself, without the quote./
#+END_cartouche

** THE PROBLEM OF MISQUOTING

#+CINDEX:quoting mistakes
It is easy for beginning Lisp programmers to get confused about quoting and
either put quotes in the wrong place or leave them out where they are needed.

The error messages Lisp gives are a good hint about what went wrong.

- An unassigned variable or undefined function error usually indicates that a
  quote was left out:
  : (list ’a ’b c) ⇒ Error! C unassigned variable.
  : (list ’a ’b ’c) ⇒ (a b c)

  : (cons ’a (b c)) ⇒ Error! B undefined function.
  : (cons ’a ’(b c)) ⇒ (a b c)

- On the other hand, wrong-type input errors or funny results may be an
  indication that a quote was put in where it doesn’t belong.
  : (+ 10 ’(- 5 2)) ⇒ Error! Wrong type input to +.
  : (+ 10 (- 5 2)) ⇒ 13

  : (list ’buy ’(* 27 34) ’bagels)
  :     ⇒ (buy (* 27 34) bagels)

  : (list ’buy (* 27 34) ’bagels)
  :     ⇒ (buy 918 bagels)

- When we quote a list, the quote must go outside the list to prevent the list
  from being evaluated. If we put the quote inside the list, EVAL will try to
  evaluate the list and an error will result:
  : (’foo ’bar ’baz) ⇒ Error! ’FOO undefined function.
  : ’(foo bar baz) ⇒ (foo bar baz)

** THREE WAYS TO MAKE LISTS

We have three ways to make lists using EVAL notation:

1. We can write the list out directly, using a quote to prevent its evaluation,
   like this:
   : ’(foo bar baz) ⇒ (foo bar baz)
2. Or we can use LIST or CONS to build the list up from individual elements. If
   we use this method, we must quote each argument to the function:
   : (list ’foo ’bar ’baz) ⇒ (foo bar baz)
   : (cons ’foo ’(bar baz)) ⇒ (foo bar baz)

   One advantage of building the list up from individual elements is that some
   of the elements can be computed rather than specified directly.
   : (list 33 ’squared ’is (* 33 33))
   :    ⇒ (33 squared is 1089)

** FOUR WAYS TO MISDEFINE A FUNCTION

#+CINDEX:function definition, syntactically correct
Beginning users of EVAL notation sometimes have trouble writing syntactically
correct function definitions. Let’s take a close look at a proper definition
for the function INTRO:
: (defun intro (x y) (list x ’this ’is y))
: (intro ’stanley ’livingstone) ⇒
:     (stanley this is livingstone)

Notice that INTRO’s argument list consists of two symbols, X and Y, with
neither quotes nor parentheses around them, and the variables X and Y are not
quoted or parenthesized in the body, either.

The first way to misdefine a function is to put something other than plain,
unadorned symbols in the function’s argument list. If we put quotes or extra
levels of parentheses in the argument list, the function won’t work. Beginners
are sometimes tempted to do this when they write a function that is to be
called with a list instead of a symbol as input. This is always a mistake.
: (defun intro (’x ’y) bad argument list
:     (list x ’this ’is y))

: (defun intro ((x) (y)) bad argument
:     list (list x ’this ’is y))

The second way to misdefine a function is to put parentheses around variables
where they appear in the body. Only function calls should have parentheses
around them. Putting parentheses around a variable will cause an undefined
function error:
: (defun intro (x y) (list (x) ’this ’is (y)))
: (intro ’stanley ’livingstone)
:     ⇒ Error! X undefined function.

** MORE ABOUT VARIABLES

#+CINDEX:create variables automatically, in function
#+CINDEX:variables, automatic creation in functions
#+CINDEX:functions, create variables automatically
In Lisp, a function creates variables automatically when it is is invoked; they
(usually) go away when the function returns.  Consider the DOUBLE function,
which creates a variable named N every time we call it:
: (defun double (n) (* n 2))

#+CINDEX:global variables
Outside of DOUBLE, the symbol N refers to the /global/ variable named N. The
global variable N has not been assigned any value, so evaluating N results in
an error.
: n ⇒ Error! N unassigned variable.

Now let’s try an example with two variables. Here is a definition for QUADRUPLE
in terms of DOUBLE:
: (defun quadruple (n) (double (double n)))

Both DOUBLE and QUADRUPLE call their input N. Suppose we evaluate the
expression (QUADRUPLE 5) as in the diagram on the next page. When we enter
QUADRUPLE, Lisp creates a new variable N with value 5 and evaluates the
expression (DOUBLE (DOUBLE N)). What happens when we call DOUBLE with input 5?
DOUBLE creates its own variable N, bound to its own input, which is 5. The body
of DOUBLE evaluates to 10. Now we have evaluated (DOUBLE N), so we can use that
result to evaluate (DOUBLE (DOUBLE N)). DOUBLE is called again, this time with
input 10, so it creates yet another variable named N, binds it to 10, and
evaluates (* N 2). After DOUBLE returns 20, QUADRUPLE returns 20 as its result,
and we end up back at top level again, where the name N refers to the global
variable N, still with no value assigned.

** SUMMARY

#+CINDEX:eval notation
#+CINDEX:expressions represented as lists
#+CINDEX:lists, expressions
In this chapter we learned EVAL notation, which allows expressions to be
represented as lists. Lists are interpreted by the EVAL function according to a
built-in set of evaluation rules. The evaluation rules we learned were:

#+CINDEX:evaluation rules
#+CINDEX:self-evaluating, numbers, t, nil
#+CINDEX:numbers, self-evaluating
- Numbers are self-evaluating, meaning they evaluate to themselves. So do T and
  NIL.

#+CINDEX:list, evaluation rules
- When evaluating a list, the first element specifies a function to call, and
  the remaining elements specify its arguments. The arguments are evaluated
  from left to right to derive the inputs that are passed to the function.

#+CINDEX:symbols, evaluation rules, variable references
#+CINDEX:variable references, symbols
#+CINDEX:unassigned variables error
#+CINDEX:error, unassigned variable
- Symbols appearing anywhere other than the first element of a list are
  interpreted as variable references. A symbol evaluates to the value of the
  variable it names. Exactly which variable a symbol is referring to depends on
  the context in which the symbol appears. Variables that haven’t been assigned
  values cause ``unassigned variable'' errors when the symbol is evaluated.

#+CINDEX:quoted list, evaluation rule
- A quoted list or symbol evaluates to itself, without the quote.


A list of form:
: (DEFUN function-name (argument-list) function-body)
defines a function. DEFUN is a special kind of function; its inputs do not have
to be quoted. A function’s argument list is a list of symbols giving names to
the function’s inputs. Inside the body of the function, the variables that hold
Ithe function’s inputs can be referred to by these symbols.

*** FUNCTIONS COVERED IN THIS CHAPTER

#+CINDEX:evaluator, eval
#+CINDEX:eval, evaluator
- The evaluator: EVAL.

#+CINDEX:macro function
#+CINDEX:defun, macro function
- Macro function for defining new functions: DEFUN.

** Lisp on the Computer

#+CINDEX:lisp on a computer
Congratulations! Having made it successfully through all the pencil-and-paper
work, it’s time for you to learn how to use Lisp on a real computer.

*** RUNNING LISP
The first thing you need to find out is how to start up Lisp on your computer.

When Lisp starts up it prints a greeting message. Each implementation has its
own style of greeting, but a typical message looks something like this:

#+BEGIN_EXAMPLE
CMU Common Lisp M2.8 (29-Mar-89)
Hemlock M3.0 (29-Mar-89), Compiler M1.7 (29-Mar-89)
Send bug reports and questions to Gripe.
>
#+END_EXAMPLE

The =>= character that appears after the greeting is called a *top-level
prompt*.  It indicates that Lisp is waiting for you to type something. Some
Lisps use a different prompt character; many use =*= (an asterisk).

The next thing you need to find out is which control characters your Lisp uses,
specifically:

- How do you delete a character: by pressing {{{key(Delete)}}},
  {{{key(Backspace)}}}, or some other key?

- How do you throw away a line of input so you can start over? In some Lisps
  you can discard a line before hitting {{{key(Return)}}} by typing a
  {{{kbd(C-u)}}}.  (While holding down the {{{key(Control)}}} key, press the
  {{{kbd(u)}}} key.)  Other Lisps use a different character.

- What is the =abort= character that gets you back to the top-level prompt?
  Many Lisps use {{{kbd(C-g)}}} or {{{kbd(C-c)}}} for this purpose.


While we’re on the subject of special characters, remember that computers
always provide separate keys for the letter {{{kbd(O)}}} and the digit
{{{kbd(0)}}}, and for the letter {{{kbd(l)}}} and the digit {{{kbd(1)}}}.  On
conventional typewriters it’s fine to type {{{kbd(O)}}} for {{{kbd(0)}}} or
{{{kbd(l)}}} for {{{kbd(1)}}}, but when you talk to a computer you must be sure
to use the correct character for what you mean.

Finally, you need to find out how to get out of Lisp when you’re done. Most
Lisps require you to type something like ~(QUIT)~ or ~(EXIT)~ to
leave. Sometimes an end-of-file character like {{{key(Control-D)}}} will also
work.

*** THE READ-EVAL-PRINT LOOP

#+CINDEX:read-eval-print loop
A computer running Lisp behaves a lot like a pocket calculator.  It reads an
expression that you type on the keyboard, evaluates it (using EVAL), and prints
the result on the screen.  Then it prints another prompt and waits for you to
type the next expression.  This process is called a {{{dfn(read-eval-print
loop)}}}.

*** TODO RECOVERING FROM ERRORS

#+CINDEX:error, recover from
A very important thing to learn at this point is how to recover from errors.

{{{heading(Typing Errors)}}}

#+CINDEX:error, typing
#+CINDEX:@key{C-g}
First let’s consider typing errors.  If after entering a long expression I
realize I’ve made a typing error near the beginning, I may want to throw away
the entire expression and start over. In my Lisp, the way to do that is to type
{{{kbd(Control-G)}}} to get back to the top-level prompt.

{{{heading(Evaluation Errors)}}}

#+CINDEX:error, evaluation
#+CINDEX:read-eval-print loop for debugger
A more common problem is an expression that is typed correctly but results in
an evaluation error.  Trying to add a number and a symbol is an example.  When
an evaluation error occurs, Lisp prints an error message and puts you in a
different kind of input loop.  Instead of talking to the top-level
read-eval-print loop, you are now talking to the *debugger’s* read-eval-print
loop.  We’ll learn how to use the debugger in Chapter 8.

#+CINDEX:abort character, @kbd{C-g}
For now, all you need to know is how to get out of the debugger and back to top
level. In my Lisp, {{{kbd(Control-G)}}} is the abort character that gets me out
of the debugger and back to top level.

#+CINDEX:function, redefine
If you define a function in Lisp and it doesn’t work, you can redefine it and
try again. You can redefine a function as often as you like; only the last
definition is retained.

** Lisp Toolkit---ED

#+CINDEX:Lisp Toolkit
#+CINDEX:tools, Lisp Toolkit
The Lisp Toolkit sections appearing in this and subsequent chapters will
introduce you to the important tools of the Lisp programming environment. Some
of these tools, such as language-specific editors, program formatters, and
source-level debuggers, are available today for other languages, but they first
appeared in Lisp.

#+CINDEX:SDRAW
#+CINDEX:DTRACE
Other tools remain unique to Lisp, and two of them are unique to this book:
- SDRAW
- DTRACE

The source listings for both appear in an appendix.

#+CINDEX:ED
#+CINDEX:Lisp editor, ed
The tool we will cover first is the Lisp editor. The Common Lisp standard does
not specify what sort of editor should be provided with a Lisp implementation,
so I can’t tell you exactly how your editor works. But I can tell you something
about Lisp editors in general, why they’re different from ordinary text
editors, and why you ought to take the time to learn to use whatever editor
your Lisp provides.

#+BEGIN_QUOTE
The most frequently occurring errors in LISP are parenthetical errors. It is
thus almost imperative to employ some sort of counting or pairing device to
check parentheses every time that a function is changed.
@@texinfo:@author Elaine Gord, ``Notes on the debugging of LISP programs,'' 1964.@@
#+END_QUOTE

The above quote was written 25 years ago, when Lisp programs were typed on
punched cards. Today, of course, we use interactive editors. Lisp editors are
not ordinary text editors: They ``understand'' the syntax of Lisp programs. On
my machine, whenever I type a right parenthesis, the editor flashes the
corresponding left parenthesis for me. This keeps me from making a
``parenthetical error'' when entering Lisp expressions. Another one of my
editor’s jobs is to automatically indent every line as I type it. If a function
definition takes several lines, it will be indented in a neat and orderly
format that is easy to read.

There are two more things a good Lisp editor provides.

1. One is an easy way to *evaluate expressions while editing*. You can position
   the cursor (or mouse) on a function definition, hit a few keys, and that
   function definition will be evaluated without ever leaving the editor.

2. The second thing a good editor provides is *rapid access to online
   documentation*. If I want to see the documentation for any Lisp function or
   variable, I can call it up with just a few keystrokes. The editor also
   provides online documentation about itself.


#+CINDEX:ED
#+CINDEX:interface, Lisp implementation and editor
The Common Lisp standard specifies the interface between a Lisp implementation
and the editor it provides.  The interface is a function called ED.  Typing
{{{kbd((ED))}}} when at the top-level read-eval-print loop causes you to enter
the editor, but many Lisps also provide faster ways, such as by typing a
character like {{{kbd(Control-E)}}}.

** Advanced Topics

*** FUNCTIONS OF NO ARGUMENTS

#+CINDEX:empty list
#+CINDEX:nil, empty list
#+CINDEX:empty argument list
Suppose we wanted to write a function that multiplies 85 by 97. Notice that
this function requires no inputs; it does its computation using only
prespecified constants. Since the function doesn’t take any inputs, when we
write its definition, it will have an empty argument list. The empty list, of
course, is NIL. Let’s define this function under the name TEST:
: (defun test () (* 85 97))
After doing this, we see that
:(test) ⇒ 8245
: (test 1) ⇒ Error! Too many arguments.
: test ⇒ Error! TEST unbound variable.

*** THE QUOTE SPECIAL FUNCTION

#+CINDEX:quote
#+CINDEX:special function
QUOTE is a special function: Its input does not get evaluated. The QUOTE
special function simply returns its input. For example:
: (quote foo) ⇒ foo
: (quote (hello world)) ⇒ (hello world)

Early versions of Lisp used QUOTE instead of an apostrophe to indicate that
something shouldn’t be evaluated. That is, where we would write:
: (cons ’up ’(down sideways))
old-style Lisp programmers would write
: (cons (quote up) (quote (down sideways)))

#+CINDEX:apostrophe
Modern Lisp systems use the apostrophe as shorthand for QUOTE. Internally,
however, they convert the apostrophe to QUOTE.
: (first ''foo) => QUOTE
: (length ''foo) => 2

*** INTERNAL STRUCTURE OF SYMBOLS

#+CINDEX:symbols
#+CINDEX:composite objects, symbols
So far in this book we have been drawing symbols by writing their names. But
symbols in Common Lisp are actually {{{dfn(composite)}}} objects, meaning they
have several parts to them. Conceptually, a {{{dfn(symbol)}}} is /a block of
five pointers/, one of which points to the representation of the symbol’s
name. The others will be defined later. The internal structure of the symbol
FRED looks like this:

#+BEGIN_EXAMPLE
|__________________
| name        •-----> "FRED"
|__________________
|__________________
|__________________
|__________________
|__________________
#+END_EXAMPLE

#+CINDEX:string
The ``FRED'' appearing above in quotation marks is called a
string. {{{dfn(Strings)}}} are sequences of characters; they will be covered
more fully in Chapter 9. For now it suffices to note that strings are used to
store the names of symbols; a symbol and its name are actually two different
things.

Some symbols, like CONS or {{{command(+)}}}, are used to name built-in Lisp
functions. The symbol CONS has a pointer in its function cell to a ‘‘compiled
code object’’ that represents the machine language instructions for creating
new cons cells.

#+BEGIN_EXAMPLE
|__________________
| name        •-----> "CONS"
|__________________
|__________________
| function    •-----> compiled CONS function
|__________________
|__________________
|__________________
#+END_EXAMPLE

#+CINDEX:symbol-name
#+CINDEX:symbol-function
We can extract the various components of a symbol using built-in Common Lisp
functions like SYMBOL-NAME and SYMBOL-FUNCTION.  The following dialog
illustrates this; you’ll see something slightly different if you try it on your
computer, but the basic idea is the same.

#+BEGIN_EXAMPLE
> (symbol-name ’equal)
  "EQUAL"
> (symbol-function ’equal)
  #<Compiled EQUAL function {60463B0}>
#+END_EXAMPLE

*** LAMBDA NOTATION

#+CINDEX:Church, Alonzo
#+CINDEX:lambda notation
Lambda notation was created by Alonzo Church, a mathematician at Princeton
University. Church wanted a clear, unambiguous way to describe functions, their
inputs, and the computations they perform. In lambda notation, a function that
adds 3 to a number would be written as shown below; the λ is the Greek letter
lambda: ~λx.(3+x)~.

#+CINDEX:McCarthy, John
John McCarthy, the originator of Lisp, was a student of Church. He adopted
Church’s notation for specifying functions. The Lisp equivalent of the unnamed
function λx.(3+x) is the list:
: (lambda (x) (+ 3 x))

A function ~f(x,y) = 3x+y2~ would be written ~λ(x,y).(3x+y2)~ in lambda
notation. In Lisp it is written:
: (lambda (x y) (+ (* 3 x) (* y y)))

#+CINDEX:lambda marker
#+CINDEX:eval, lambda marker
#+CINDEX:defun
As you can see, the syntax of lambda expressions in Lisp is similar to that of
Church’s notation, and even more similar to DEFUN. But unlike DEFUN, LAMBDA is
not a function; it is a marker treated specially by EVAL. We’ll learn more
about lambda expressions in chapter 7.

#+CINDEX:associate names with functions
DEFUN’s job is to associate names with functions. When typing in a new function
definition, such as for =HALF=, there are two kinds of naming going on. The
string ``HALF'' names the symbol, and the symbol =HALF= names the function.

In the diagram below, you can see the name cell of =HALF= pointing to the
string ``HALF''. Its function cell points to a function object that is the real
function. Exactly what this function object looks like depends on which
implementation of Common Lisp you’re using, but as the diagram indicates,
there’s probably a lambda expression in there somewhere.

#+BEGIN_EXAMPLE
|__________________
| name        •-----> "HALF"
|__________________
|__________________
| function    •-----> function object •-----> LAMBDA (N) (/ N 2))
|__________________
|__________________
|__________________
#+END_EXAMPLE

Of course, the lambda expression is just a list constructed out of cons
cells. And each of the symbols in the lambda expression, such as =N= and =/=,
is really a block of five pointers. Since the symbol =/= names the division
function, it contains a pointer to a built-in function object for performing
division. So, indirectly, HALF points to the built-in division function.

*** SCOPE OF VARIABLES

#+CINDEX:scope of variable
#+CINDEX:local variable
#+CINDEX:global variable
The {{{dfn(scope)}}} of a variable is /the region in which it may be
referenced/.  For example, the variable N that holds the input to HALF has
scope limited to the body of HALF. Another way to express this is to say that
the variable N is *local* to HALF.  *Global* variables have unbounded scope;
they may be referenced anywhere.

#+CINDEX:evaltrace diagram
In an evaltrace diagram, the scope of a local variable is delimited by the
thick arrow containing the creation of that variable.  Outside the thick arrow
the variable cannot be referenced.

*** EVAL AND APPLY

#+CINDEX:eval
EVAL is a Lisp primitive function. Each use of EVAL gives one level of
evaluation.
: (eval ’(+ 2 2)) ⇒ 4

We won’t use EVAL explicitly in any of the programs we write, but we make
implicit use of it all the time. You can think of the computer as a physical
manifestation of EVAL. When it runs Lisp, everything you type is evaluated.

#+CINDEX:apply, primitive function
#+CINDEX:@kbd{#'}, quote function
#+CINDEX:quote function, @kbd{#'}
APPLY is also a Lisp primitive function.  APPLY takes a function and a list of
objects as input.  It invokes the specified function with those objects as its
inputs.  The first argument to APPLY should be quoted with =#'= rather than an
ordinary quote; =#'= is the proper way to quote functions supplied as inputs to
other functions.  This will be explained in more detail in Chapter 7.
: (apply #’+ ’(2 3)) ⇒ 5
: (apply #’equal ’(12 17)) ⇒ nil

The objects APPLY passes to the function are not evaluated first. In the
following example, the objects are a symbol and a list. Evaluating either the
symbol =AS= or the list =(YOU LIKE IT)= would cause an error.
: (apply #’cons ’(as (you like it))) ⇒ (as you like it)

EVAL and APPLY are related to each other. A popular exercise in more advanced
Lisp texts involves writing each function in terms of the other.

*** FUNCTIONS COVERED IN ADVANCED TOPICS

#+CINDEX:apply
#+CINDEX:eval
#+CINDEX:quote
- EVAL-related function: APPLY.
- EVAL (used explicitly).
- Special function: QUOTE.

* List of Tables
  :PROPERTIES:
  :UNNUMBERED: t
  :END:
  #+TEXINFO: @listoffloats Table
* Concept Index
  :PROPERTIES:
  :INDEX:    cp
  :END:
* COPYING
  :PROPERTIES:
  :COPYING:  t
  :END:

  {{{title}}}---{{{subtitle}}} {{{break}}}
  By {{{author}}} {{{break}}}
  \copy {{{date}}}

* DEFAULT EXPORT SETTINGS                                          :noexport:
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+OPTIONS: author:t broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:t todo:t |:t
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 26.1 (Org mode 9.1.14)
* TEXINFO EXPORT SETTINGS                                          :noexport:
#+TEXINFO_FILENAME:cl-gentleintro.info
#+TEXINFO_CLASS: info
#+TEXINFO_HEADER:
#+TEXINFO_POST_HEADER:
#+SUBAUTHOR:
#+TEXINFO_DIR_CATEGORY:Lisp
#+TEXINFO_DIR_TITLE:Common List Gentle Intro
#+TEXINFO_DIR_DESC:Gentle introduction to symbolic computation
#+TEXINFO_PRINTED_TITLE:Common Lisp
* MACRO DEFINITIONS                                                :noexport:
#+MACRO: subtitle A Gentle Introduction to Symbolic Computation
#+MACRO: VERSION Version 0.6.9 <2019-02-27 Wed 20:15>
#+MACRO: noindent @@texinfo:@noindent @@
#+MACRO: break @@texinfo:@*@@
#+MACRO: heading @@texinfo:@heading @@ $1
#+MACRO: subheading @@texinfo:@subheading @@ $1
#+MACRO: dfn @@texinfo:@dfn{@@$1@@texinfo:}@@
#+MACRO: code @@texinfo:@code{@@$1@@texinfo:}@@
#+MACRO: command @@texinfo:@command{@@$1@@texinfo:}@@
#+MACRO: result @@texinfo:@result{}@@
#+MACRO: kbd @@texinfo:@kbd{@@$1@@texinfo:}@@
#+MACRO: key @@texinfo:@key{@@$1@@texinfo:}@@
* Footnotes

[fn:add1]Note to instructors: Common Lisp contains built-in functions 1+ and 1-
that add 1 to or subtract 1 from their input, respectively. But since these
unusual names are almost certain to confuse beginning programmers, I will not
refer to them in this book.

[fn:2] DEFUN stands for define function.

[fn:1] We’ll explore this possibility further in chapter 7.
